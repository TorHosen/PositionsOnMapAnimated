<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Device Animation Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Leaflet Measure Plugin CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-measure/dist/leaflet-measure.css" />
  <style>
    body {
      display: flex;
      flex-direction: row;
      margin: 0;
      font-family: sans-serif;
    }
    /* Map container */
    #map {
      height: 100vh;
      width: 75%;
      position: relative;
    }
    /* Watermark styling */
    #watermark {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 100px;
      color: rgba(0, 0, 0, 0.1);
      pointer-events: none;
      z-index: 1000;
    }
    #controls {
      width: 25%;
      padding: 15px;
      background: #f9f9f9;
      box-shadow: -2px 0 5px rgba(0,0,0,0.1);
      overflow-y: auto;
    }
    /* Import areas: hidden on load, original size */
    #importArea, #pastureImportArea {
      width: 100%;
      height: 150px;
      display: none;
    }
    #deviceList, #pastureList {
      margin-top: 20px;
    }
    .device-entry, .pasture-entry {
      margin: 10px 0;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      width: 100%;
    }
    .device-entry label, .pasture-entry label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
    }
    /* DivIcon styling for custom shapes */
    .custom-marker-icon {
      background: none;
      border: none;
    }
    .custom-icon {
      font-size: 20px;
      line-height: 20px;
      text-align: center;
      width: 24px;
      height: 24px;
    }
    /* Animated pulse marker for "heart" style */
    .pulse-marker {
      width: 12px;
      height: 12px;
      background-color: red;
      border: 2px solid black;
      border-radius: 50%;
      opacity: 0.8;
      animation: pulse 1s infinite ease-in-out;
    }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.6); opacity: 0.5; }
      100% { transform: scale(1); opacity: 1; }
    }
    /* Marker Style Options control */
    #iconControls {
      margin-top: 15px;
      padding: 5px;
      border: 1px solid #ccc;
    }
    #iconControls h4 { margin: 5px 0; }
    #iconControls label { display: block; margin: 5px 0; }
    /* Login overlay styles */
    #loginOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    #loginOverlay form {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
    }
    #loginOverlay input {
      margin: 10px 0;
      padding: 5px;
      width: 200px;
    }
  </style>
</head>
<body>
  <!-- Login Overlay -->
  <div id="loginOverlay">
    <form id="loginForm" autocomplete="on">
      <h3>Login</h3>
      <div>
        <label>
          Username:<br>
          <input type="text" id="username" name="username" required>
        </label>
      </div>
      <div>
        <label>
          Password:<br>
          <input type="password" id="password" name="password" required>
        </label>
      </div>
      <div>
        <button type="submit">Login</button>
      </div>
    </form>
  </div>
  
  <!-- Main content -->
  <div id="map">
    <div id="watermark">NOFENCE</div>
  </div>
  <div id="controls">
    <button onclick="startAnimation()">Start</button>
    <button onclick="pauseAnimation()">Pause</button>
    <button onclick="rewindAnimation()">‚èÆ Rewind</button>
    <button onclick="clearAnimation()">Clear Animation</button>
    <br><br>
    <label>Speed:
      <input type="range" id="speedSlider" min="1" max="100" value="10" step="1" oninput="changeSpeed(this.value)">
    </label>
    <br><br>
    <label><input type="checkbox" onchange="toggleTrails(this.checked)"> Show Trails</label>
    <br>
    <label><input type="checkbox" onchange="toggleShortTrails(this.checked)"> Show Short Trails</label>
    <br>
    <label>
      <input type="checkbox" id="showAllPositionsCheckbox" onchange="handleShowAllPositionsChange(this.checked)"> 
      Show All Positions
    </label>
    <br>
    <label><input type="checkbox" onchange="toggleAccuracyRings(this.checked)"> Show Accuracy Rings</label>
    <br>
    <label>
      <input type="checkbox" id="toggleMessageStatus" onchange="toggleTimelineBar(this.checked)">
      Show Message Status Bar
    </label>
    <br><br>
    <label>
      Filter eFenceStatus:
      <select id="fenceStatusFilter" multiple style="width:100%; height:80px;" onchange="updatePositionFilter()"></select>
    </label>
    <br><br>
    <button id="toggleBeaconPolygonBtn" onclick="toggleBeaconPolygon()">Draw Beacon Polygon</button>
    <br><br>
    <input type="range" id="timeSlider" min="0" max="100" value="0" style="width:100%" oninput="seekTime(this.value)" />
    <div><span id="timestamp"></span></div>
    <br>
    <button onclick="toggleImportBox()">Import Positions</button>
    <br>
    <textarea id="importArea" placeholder="Paste CSV data here..."></textarea>
    <br>
    <button onclick="loadPositionData()">Load Data</button>
    <br><br>
    <button onclick="togglePastureImportBox()">Import Pastures</button>
    <br>
    <textarea id="pastureImportArea" placeholder="Paste pasture data here..."></textarea>
    <br>
    <button onclick="loadPastureData()">Load Pastures</button>
    <div id="deviceList"></div>
    <div style="margin-top: 10px;">
      <input type="color" id="bulkColorPicker" value="#003f8a" />
      <button onclick="setAllDeviceColors()">Set All Device Colors</button>
    </div>
    <div id="pastureList"></div>
    <hr>
    <!-- Marker Style Options -->
    <div id="iconControls">
      <h4>Marker Style Options</h4>
      <div>
        <label>
          Pulse Marker:
          <select id="pulseMarkerStyle" onchange="updatePulseMarkerStyle(this.value)">
            <option value="heart" selected>Animated Red Circle (Pulse)</option>
            <option value="circle">Static Red Circle</option>
          </select>
        </label>
      </div>
      <div>
        <label>
          Warning Marker:
          <select id="warningMarkerStyle" onchange="updateWarningMarkerStyle(this.value)">
            <option value="yellowCircle" selected>Yellow Circle (Default)</option>
            <option value="singleMusic">Single Music Note (Yellow)</option>
          </select>
        </label>
      </div>
    </div>
    <small style="display:block; margin-top:10px; font-size:0.85em; color:#555;">
      üêû Report bugs to <a href="mailto:tor@nofence.no">tor@nofence.no</a>
    </small>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Leaflet Measure Plugin JS -->
  <script src="https://unpkg.com/leaflet-measure/dist/leaflet-measure.js"></script>
  <script>
    /* Global variables */
    let deviceData = {}, deviceMarkers = {}, deviceLines = {}, deviceColors = {};
    let deviceStats = {}, pastureLayers = [], pastureInfo = {};
    let deviceVisibility = {};
    let showTrails = false, showShortTrails = false;
    let animationSpeed = 10;
    let currentIndex = 0, allTimestamps = [], animationInterval = null;
    let allPositionMarkers = [], allAccuracyRings = [];
    let allPositionsShown = false, showAccuracyRings = false;
    let showTimelineBar = false;
    let beaconPolygon = null;
    let allUniqueStatuses = new Set();

    const brightColors = [
      '#00FF00','#0099FF','#FF3333','#FF9900','#CC33FF',
      '#FFFF00','#00FFFF','#FF00FF','#FF66CC','#66FF33'
    ];

    /* Marker style settings for pulse and warning */
    let pulseMarkerStyle = "heart";          // "heart" => animated red circle, "circle" => static red circle
    let warningMarkerStyle = "yellowCircle"; // "yellowCircle" or "singleMusic"

    function updatePulseMarkerStyle(val) {
      pulseMarkerStyle = val;
      updateFrame(currentIndex);
    }
    function updateWarningMarkerStyle(val) {
      warningMarkerStyle = val;
      updateFrame(currentIndex);
    }

    /* Create the map and add scale control */
    const map = L.map('map').setView([0, 0], 2);
    L.control.scale({ position: 'bottomleft', maxWidth: 200, metric: true, imperial: false }).addTo(map);

    /* Base layers */
    const baseLayers = {
      'osm': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors',
        maxZoom: 22
      }),
      'norgeskart': L.tileLayer(
        'https://cache.kartverket.no/v1/wmts/1.0.0/topo/default/webmercator/{z}/{y}/{x}.png',
        { attribution: '&copy; <a href="http://www.kartverket.no/">Kartverket</a>' }
      ),
      'norgeskart Gray': L.tileLayer(
        'https://cache.kartverket.no/v1/wmts/1.0.0/topograatone/default/webmercator/{z}/{y}/{x}.png',
        { attribution: '&copy; <a href="http://www.kartverket.no/">Kartverket</a>' }
      ),
      'satellite': L.tileLayer(
        'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          attribution: 'Tiles &copy; Esri'
        }
      )
    };

    let currentBaseLayer = baseLayers['osm'];
    currentBaseLayer.addTo(map);

    /* Base layer control with dropdown */
    const layerSelectControl = L.control({position: 'topleft'});
    layerSelectControl.onAdd = function (map) {
      let div = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
      div.style.backgroundColor = 'white';
      div.style.padding = '5px';
      div.innerHTML = `
        <select id="baseLayerSelect" onchange="switchBaseLayer(this.value)">
          <option value="osm">OpenStreetMap</option>
          <option value="norgeskart">Norgeskart (Topo)</option>
          <option value="norgeskart Gray">Norgeskart (Gray)</option>
          <option value="satellite">Satellite</option>
        </select>
      `;
      return div;
    };
    layerSelectControl.addTo(map);

    function switchBaseLayer(layerName) {
      if (currentBaseLayer) map.removeLayer(currentBaseLayer);
      currentBaseLayer = baseLayers[layerName];
      map.addLayer(currentBaseLayer);
    }

    /* Add measure control */
    const measureControl = new L.Control.Measure({
      primaryLengthUnit: 'meters',
      secondaryLengthUnit: 'kilometers',
      primaryAreaUnit: 'sqmeters',
      secondaryAreaUnit: 'hectares',
      activeColor: '#ABE67E',
      completedColor: '#C8F2BE'
    });
    measureControl.addTo(map);

    /* Toggle Accuracy Rings */
    function toggleAccuracyRings(checked) {
      showAccuracyRings = checked;
      if (allPositionsShown) showAllPositions();
    }
    window.toggleAccuracyRings = toggleAccuracyRings;

    /* Toggle timeline bar in device list */
    function toggleTimelineBar(show) {
      showTimelineBar = show;
      renderDeviceColorControls();
    }

    /* Hide watermark when pastures are loaded */
    function hideWatermark() {
      const wm = document.getElementById('watermark');
      if (wm) wm.style.display = 'none';
    }

    /* Helper to create marker for each position, depending on msg type */
    function createMarker(pos, device_id) {
      const msgType = pos.msg.trim();
      let marker;
      if (msgType === 'pulse') {
        if (pulseMarkerStyle === 'heart') {
          const icon = L.divIcon({
            html: '<div class="pulse-marker"></div>',
            className: 'custom-marker-icon'
          });
          marker = L.marker([pos.lat, pos.lon], { icon });
        } else {
          marker = L.circleMarker([pos.lat, pos.lon], {
            radius: 4,
            color: 'black',
            weight: 1,
            fillColor: 'red',
            fillOpacity: 1
          });
        }
      } else if (msgType === 'warning') {
        if (warningMarkerStyle === 'yellowCircle') {
          marker = L.circleMarker([pos.lat, pos.lon], {
            radius: 4,
            color: 'black',
            weight: 1,
            fillColor: 'yellow',
            fillOpacity: 1
          });
        } else if (warningMarkerStyle === 'singleMusic') {
          // Single music note in yellow with black outline via text-shadow
          const iconHtml = `<div class="custom-icon" style="color: yellow; text-shadow: -1px -1px 0 black, 1px -1px 0 black, -1px 1px 0 black, 1px 1px 0 black;">‚ô´</div>`;
          const icon = L.divIcon({
            html: iconHtml,
            className: 'custom-marker-icon',
            iconSize: [20, 20]
          });
          marker = L.marker([pos.lat, pos.lon], { icon });
        }
      } else {
        marker = L.circleMarker([pos.lat, pos.lon], {
          radius: 4,
          color: 'black',
          weight: 1,
          fillColor: deviceColors[device_id] || '#003f8a',
          fillOpacity: 1
        });
      }
      return marker;
    }

    /* Show all positions (ignoring filter) */
    function showAllPositions() {
      allPositionMarkers.forEach(m => map.removeLayer(m));
      allPositionMarkers = [];
      allAccuracyRings.forEach(r => map.removeLayer(r));
      allAccuracyRings = [];
      Object.entries(deviceData).forEach(([device_id, positions]) => {
        if (!deviceVisibility[device_id]) return;
        positions.forEach(pos => {
          const marker = createMarker(pos, device_id).addTo(map);
          marker.markerType = (pos.msg.trim() === 'warning' || pos.msg.trim() === 'pulse') 
                               ? pos.msg.trim() 
                               : 'normal';
          allPositionMarkers.push(marker);
          const msgType = pos.msg.trim();
          let ringColor = deviceColors[device_id] || '#003f8a';
          if (msgType === 'warning') ringColor = 'yellow';
          else if (msgType === 'pulse') ringColor = 'red';
          if (showAccuracyRings && pos.acc !== null && !isNaN(pos.acc)) {
            const accCircle = L.circle([pos.lat, pos.lon], {
              radius: pos.acc,
              color: ringColor,
              weight: 1,
              fillOpacity: 0.2
            }).addTo(map);
            allAccuracyRings.push(accCircle);
          }
        });
      });
    }

    /* Show filtered positions (based on eFenceStatus) */
    function showFilteredPositions() {
      allPositionMarkers.forEach(m => map.removeLayer(m));
      allPositionMarkers = [];
      allAccuracyRings.forEach(r => map.removeLayer(r));
      allAccuracyRings = [];
      let filterElement = document.getElementById('fenceStatusFilter');
      let selectedStatuses = Array.from(filterElement.selectedOptions).map(o => o.value);
      Object.entries(deviceData).forEach(([device_id, positions]) => {
        if (!deviceVisibility[device_id]) return;
        positions.forEach(pos => {
          if (selectedStatuses.length > 0 && !selectedStatuses.includes(pos.eFenceStatus)) return;
          const marker = createMarker(pos, device_id).addTo(map);
          marker.markerType = (pos.msg.trim() === 'warning' || pos.msg.trim() === 'pulse') 
                               ? pos.msg.trim() 
                               : 'normal';
          allPositionMarkers.push(marker);
          const msgType = pos.msg.trim();
          let ringColor = deviceColors[device_id] || '#003f8a';
          if (msgType === 'warning') ringColor = 'yellow';
          else if (msgType === 'pulse') ringColor = 'red';
          if (showAccuracyRings && pos.acc !== null && !isNaN(pos.acc)) {
            const accCircle = L.circle([pos.lat, pos.lon], {
              radius: pos.acc,
              color: ringColor,
              weight: 1,
              fillOpacity: 0.2
            }).addTo(map);
            allAccuracyRings.push(accCircle);
          }
        });
      });
    }

    /* Animation update function with marker type check */
    function updateFrame(index) {
      const currentTime = allTimestamps[index];
      Object.entries(deviceData).forEach(([device_id, positions]) => {
        if (!deviceVisibility[device_id]) return;
        const filtered = positions.filter(p => p.timeMs <= currentTime.getTime());
        const pos = filtered[filtered.length - 1];
        if (!pos) return;
        const currentMsg = pos.msg.trim();
        let existingMarker = deviceMarkers[device_id];

        // For warning or pulse messages, always recreate the marker.
        // For normal messages, if an existing marker is not 'normal', recreate it.
        if (currentMsg === 'warning' || currentMsg === 'pulse') {
          if (existingMarker) {
            map.removeLayer(existingMarker);
          }
          let newMarker = createMarker(pos, device_id);
          newMarker.markerType = currentMsg;
          deviceMarkers[device_id] = newMarker.addTo(map);
        } else {
          // "normal" position
          if (existingMarker && existingMarker.markerType !== 'normal') {
            map.removeLayer(existingMarker);
            let newMarker = createMarker(pos, device_id);
            newMarker.markerType = 'normal';
            deviceMarkers[device_id] = newMarker.addTo(map);
          } else if (existingMarker) {
            existingMarker.setLatLng([pos.lat, pos.lon]);
          } else {
            let newMarker = createMarker(pos, device_id);
            newMarker.markerType = 'normal';
            deviceMarkers[device_id] = newMarker.addTo(map);
          }
        }

        // Update the device trail (polyline)
        let lineColor = deviceColors[device_id] || '#003f8a';
        if (currentMsg === 'warning') lineColor = 'yellow';
        else if (currentMsg === 'pulse') lineColor = 'red';
        if (deviceLines[device_id]) {
          deviceLines[device_id].setStyle({ color: lineColor });
        } else {
          deviceLines[device_id] = L.polyline([], { color: lineColor }).addTo(map);
        }
        const line = deviceLines[device_id];
        let trailPoints = [];
        if (showTrails) {
          trailPoints = filtered.map(p => [p.lat, p.lon]);
        } else if (showShortTrails && filtered.length >= 2) {
          trailPoints = filtered.slice(-2).map(p => [p.lat, p.lon]);
        }
        if (trailPoints.length > 0) {
          line.setLatLngs(trailPoints);
          if (!map.hasLayer(line)) map.addLayer(line);
        } else {
          line.setLatLngs([]);
          if (map.hasLayer(line)) map.removeLayer(line);
        }
      });
      document.getElementById('timestamp').textContent = currentTime.toLocaleString();
      const percent = (currentIndex / (allTimestamps.length - 1)) * 100;
      document.getElementById('timeSlider').value = percent;
    }

    /* Animation control functions using setInterval for simplicity */
    function startAnimation() {
      if (animationInterval) return;
      animationInterval = setInterval(() => {
        currentIndex++;
        if (currentIndex >= allTimestamps.length) {
          pauseAnimation();
          return;
        }
        updateFrame(currentIndex);
      }, 1000 / animationSpeed);
    }

    function pauseAnimation() {
      clearInterval(animationInterval);
      animationInterval = null;
    }

    function seekTime(percent) {
      currentIndex = Math.floor((percent / 100) * (allTimestamps.length - 1));
      updateFrame(currentIndex);
    }

    function changeSpeed(val) {
      animationSpeed = parseInt(val);
      if (animationInterval) {
        pauseAnimation();
        startAnimation();
      }
    }

    function rewindAnimation() {
      currentIndex = 0;
      updateFrame(currentIndex);
    }

    function toggleTrails(show) {
      showTrails = show;
      updateFrame(currentIndex);
    }

    function toggleShortTrails(show) {
      showShortTrails = show;
      updateFrame(currentIndex);
    }

    function toggleImportBox() {
      document.getElementById('importArea').style.display = 'block';
      document.getElementById('pastureImportArea').style.display = 'none';
    }

    function togglePastureImportBox() {
      document.getElementById('pastureImportArea').style.display = 'block';
      document.getElementById('importArea').style.display = 'none';
    }

    /* CSV parser for position data */
    function loadPositionData() {
      const raw = document.getElementById('importArea').value;
      const lines = raw.replace(/\[nl\]/g, '\n')
                       .split('\n')
                       .filter(l => l.trim() && !l.startsWith('device_id'));
      const parsed = lines.map(line => {
        const parts = line.split(',');
        const device_id = parts[0];
        const timeStr   = parts[1];
        const lonStr    = parts[2];
        const latStr    = parts[3];
        const msg       = parts[4];
        const eMode         = parts[5] || '';
        const eCollarStatus = parts[6] || '';
        const eFenceStatus  = parts[7] || '';
        const acc           = (parts.length >= 9) ? parseFloat(parts[8]) / 10 : null;
        const timeObj = new Date(timeStr);
        return {
          device_id,
          timeObj,
          timeMs: timeObj.getTime(),
          lat: parseFloat(latStr) / 1e7,
          lon: parseFloat(lonStr) / 1e7,
          msg: msg.trim(),
          eMode,
          eCollarStatus,
          eFenceStatus,
          acc
        };
      });
      deviceData = {};
      deviceStats = {};
      deviceMarkers = {};
      deviceLines = {};
      deviceVisibility = {};
      parsed.forEach(pos => {
        if (!deviceData[pos.device_id]) deviceData[pos.device_id] = [];
        if (!deviceStats[pos.device_id]) deviceStats[pos.device_id] = { pulse: 0, warning: 0 };
        if (pos.msg === 'pulse') deviceStats[pos.device_id].pulse++;
        if (pos.msg === 'warning') deviceStats[pos.device_id].warning++;
        deviceData[pos.device_id].push(pos);
      });
      Object.values(deviceData).forEach(arr => arr.sort((a, b) => a.timeMs - b.timeMs));
      const allTimes = parsed.map(p => p.timeMs);
      const uniqueSorted = [...new Set(allTimes)].sort((a, b) => a - b).map(t => new Date(t));
      allTimestamps = uniqueSorted;
      currentIndex = 0;
      renderDeviceColorControls();
      updateFrame(currentIndex);
      populateFenceStatusFilter();
      document.getElementById('importArea').style.display = 'none';
    }

    /* Populate the eFenceStatus filter */
    function populateFenceStatusFilter() {
      allUniqueStatuses = new Set();
      Object.values(deviceData).forEach(arr => {
        arr.forEach(pos => {
          if (pos.eFenceStatus) allUniqueStatuses.add(pos.eFenceStatus);
        });
      });
      let filterElement = document.getElementById('fenceStatusFilter');
      filterElement.innerHTML = '';
      allUniqueStatuses.forEach(s => {
        let option = document.createElement('option');
        option.value = s;
        option.text = s;
        option.selected = true;
        filterElement.appendChild(option);
      });
    }

    function updatePositionFilter() {
      if (allPositionsShown) {
        showFilteredPositions();
      } else {
        updateFrame(currentIndex);
      }
    }

    /* Create timeline for each device */
    function createDeviceTimeline(dev) {
      const positions = deviceData[dev];
      if (!positions || positions.length === 0) return '';
      const times = positions.map(p => p.timeMs);
      const minTime = Math.min(...times);
      const maxTime = Math.max(...times);
      if (minTime === maxTime) {
        return `
          <div style="
            position: relative;
            width: 100%;
            height: 10px;
            background: grey;
            margin-top: 5px;
            border: 1px solid #ccc;
          " title="Single timestamp"></div>
        `;
      }
      const intervalMs = 20 * 60 * 1000;
      const totalDuration = maxTime - minTime;
      let timelineHTML = `
        <div style="
          position: relative;
          width: 100%;
          height: 10px;
          background: grey;
          margin-top: 5px;
          border: 1px solid #ccc;
          overflow: hidden;
        ">
      `;
      let segments = [];
      let segStart = null, segEnd = null;
      for (let t = minTime; t <= maxTime; t += intervalMs) {
        const windowStart = t;
        const windowEnd = t + intervalMs;
        const hasPoll = positions.some(p => p.msg === 'poll' && p.timeMs >= windowStart && p.timeMs < windowEnd);
        if (hasPoll) {
          if (segStart === null) {
            segStart = windowStart; 
            segEnd = windowEnd;
          } else {
            segEnd = windowEnd;
          }
        } else {
          if (segStart !== null) {
            segments.push({ start: segStart, end: segEnd });
            segStart = null;
            segEnd = null;
          }
        }
      }
      if (segStart !== null) segments.push({ start: segStart, end: segEnd });
      segments.forEach(s => {
        const startFrac = (s.start - minTime) / totalDuration;
        const endFrac = (s.end - minTime) / totalDuration;
        const leftPercent = Math.max(0, startFrac * 100);
        const rightPercent = Math.min(100, endFrac * 100);
        const widthPercent = rightPercent - leftPercent;
        if (widthPercent <= 0) return;
        timelineHTML += `
          <div style="
            position: absolute;
            left: ${leftPercent}%;
            width: ${widthPercent}%;
            top: 0;
            height: 100%;
            background: blue;
          "></div>
        `;
      });
      const warnings = positions.filter(p => p.msg === 'warning');
      warnings.forEach(w => {
        const frac = (w.timeMs - minTime) / totalDuration;
        if (frac < 0 || frac > 1) return;
        const leftPercent = frac * 100;
        timelineHTML += `
          <div style="
            position: absolute;
            left: ${leftPercent}%;
            width: 2px;
            top: 0;
            height: 100%;
            background: yellow;
          " title="Warning at ${new Date(w.timeMs).toLocaleString()}"></div>
        `;
      });
      const pulses = positions.filter(p => p.msg === 'pulse');
      pulses.forEach(pu => {
        const frac = (pu.timeMs - minTime) / totalDuration;
        if (frac < 0 || frac > 1) return;
        const leftPercent = frac * 100;
        timelineHTML += `
          <div style="
            position: absolute;
            left: ${leftPercent}%;
            width: 2px;
            top: 0;
            height: 100%;
            background: red;
          " title="Pulse at ${new Date(pu.timeMs).toLocaleString()}"></div>
        `;
      });
      timelineHTML += '</div>';
      return timelineHTML;
    }

    /* Render device list (with timeline if enabled) */
    function renderDeviceColorControls() {
      const container = document.getElementById('deviceList');
      container.innerHTML = '<h4>Devices</h4>';
      const devices = Object.keys(deviceData);
      devices.forEach(dev => {
        if (!deviceColors[dev]) deviceColors[dev] = getRandomColor();
        deviceVisibility[dev] = true;
        const stats = deviceStats[dev] || { warning: 0, pulse: 0 };
        let timelineHTML = "";
        if (showTimelineBar) timelineHTML = createDeviceTimeline(dev);
        const div = document.createElement('div');
        div.className = 'device-entry';
        div.innerHTML = `
          <label>
            <input type="checkbox" checked onchange="toggleDeviceVisibility('${dev}', this.checked)">
            ${dev} [Warning: ${stats.warning} | Pulse: ${stats.pulse}]
            <input type="color" value="${deviceColors[dev]}" onchange="changeDeviceColor('${dev}', this.value)">
          </label>
          ${timelineHTML}
        `;
        container.appendChild(div);
      });
    }

    function setAllDeviceColors() {
      const color = document.getElementById('bulkColorPicker').value;
      Object.keys(deviceColors).forEach(dev => { deviceColors[dev] = color; });
      updateFrame(currentIndex);
      renderDeviceColorControls();
    }

    function toggleDeviceVisibility(dev, visible) {
      deviceVisibility[dev] = visible;
      if (!visible) {
        if (deviceMarkers[dev]) map.removeLayer(deviceMarkers[dev]);
        if (deviceLines[dev]) map.removeLayer(deviceLines[dev]);
        if (allPositionsShown) showAllPositions();
      } else {
        if (allPositionsShown) showAllPositions();
        else updateFrame(currentIndex);
      }
    }

    function changeDeviceColor(dev, color) {
      deviceColors[dev] = color;
      updateFrame(currentIndex);
    }

    function getRandomColor() {
      const letters = '0123456789ABCDEF';
      let color = '#';
      for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      return color;
    }

    /* Pasture data loading */
    function loadPastureData() {
      pastureLayers.forEach(layer => map.removeLayer(layer));
      pastureLayers = [];
      pastureInfo = [];
      const raw = document.getElementById('pastureImportArea').value.trim();
      const entries = raw.split('|NL|');
      const boundsGroup = L.latLngBounds();
      entries.forEach((entry, i) => {
        const match = entry.match(/^(\d+)\|(\d+)\|([^|]+)\|([^|]+)\|(.+)$/);
        if (!match) return;
        const pasture_id = match[1], pasture_version = match[2], pasture_name = match[3];
        const geoJsonRaw = match[5];
        try {
          const geoJson = eval('(' + geoJsonRaw + ')');
          if (geoJson.type === "Polygon" && Array.isArray(geoJson.coordinates)) {
            const latLngRings = geoJson.coordinates.map(ring =>
              ring.map(([lon, lat]) => { 
                const point = [lat, lon]; 
                boundsGroup.extend(point); 
                return point; 
              })
            );
            const pastureColor = brightColors[i % brightColors.length];
            const polygon = L.polygon(latLngRings, { color: pastureColor, weight: 2, fillOpacity: 0.2 }).addTo(map);
            polygon.bindPopup(`<strong>${pasture_name}</strong>`);
            pastureLayers.push(polygon);
            pastureInfo.push({ pasture_id, pasture_name, pasture_version });
          }
        } catch (e) {
          console.warn("Invalid GeoJSON in pasture entry:", e, geoJsonRaw);
        }
      });
      if (boundsGroup.isValid()) map.fitBounds(boundsGroup.pad(0.1));
      renderPastureList();
      document.getElementById('pastureImportArea').style.display = 'none';
      hideWatermark();
    }

    function renderPastureList() {
      const container = document.getElementById('pastureList');
      container.innerHTML = '<h4>Pastures</h4>';
      if (pastureLayers.length === 0) {
        container.innerHTML += '<p>No pastures loaded.</p>';
        return;
      }
      pastureLayers.forEach((layer, index) => {
        const info = pastureInfo[index] || {};
        const name = info.pasture_name || `Pasture ${index + 1}`;
        const color = layer.options.color || '#00FF00';
        const id = info.pasture_id || '‚Äî';
        const ver = info.pasture_version || '‚Äî';
        const div = document.createElement('div');
        div.className = 'pasture-entry';
        div.innerHTML = `
          <label>
            <input type="checkbox" checked onchange="togglePastureVisibility(${index}, this.checked)">
            ${name} (ID: ${id}, Ver: ${ver})
            <input type="color" value="${color}" onchange="changePastureColor(${index}, this.value)">
          </label>
        `;
        container.appendChild(div);
      });
    }

    function togglePastureVisibility(index, visible) {
      const layer = pastureLayers[index];
      if (!layer) return;
      visible ? map.addLayer(layer) : map.removeLayer(layer);
    }

    function changePastureColor(index, color) {
      const layer = pastureLayers[index];
      if (!layer) return;
      layer.setStyle({ color });
    }

    /* Beacon Polygon Functions */
    function drawBeaconPolygon() {
      let beaconPoints = [];
      Object.values(deviceData).forEach(positions => {
        positions.forEach(pos => {
          if (pos.eFenceStatus === 'BeaconContact' || pos.eFenceStatus === 'BeaconContactNormal') {
            if (pos.acc !== null && !isNaN(pos.acc)) {
              let lat = pos.lat, lon = pos.lon, r = pos.acc;
              let latRad = lat * Math.PI / 180;
              let dLat = r / 111320;
              let dLon = r / (111320 * Math.cos(latRad));
              for (let angle = 0; angle < 360; angle += 45) {
                let rad = angle * Math.PI / 180;
                let sampleLat = lat + dLat * Math.cos(rad);
                let sampleLon = lon + dLon * Math.sin(rad);
                beaconPoints.push({lat: sampleLat, lon: sampleLon});
              }
            } else {
              beaconPoints.push({lat: pos.lat, lon: pos.lon});
            }
          }
        });
      });
      if (beaconPoints.length === 0) {
        alert("No positions with BeaconContact or BeaconContactNormal found.");
        return;
      }
      let hull = convexHull(beaconPoints);
      if (beaconPolygon) map.removeLayer(beaconPolygon);
      beaconPolygon = L.polygon(hull.map(p => [p.lat, p.lon]), { color: 'blue', weight: 2, fillOpacity: 0.2 }).addTo(map);
    }

    function toggleBeaconPolygon() {
      let btn = document.getElementById("toggleBeaconPolygonBtn");
      if (beaconPolygon) {
        map.removeLayer(beaconPolygon);
        beaconPolygon = null;
        btn.innerText = "Draw Beacon Polygon";
      } else {
        drawBeaconPolygon();
        btn.innerText = "Remove Beacon Polygon";
      }
    }

    function convexHull(points) {
      points.sort((a, b) => a.lon === b.lon ? a.lat - b.lat : a.lon - b.lon);
      const cross = (o, a, b) => (a.lon - o.lon) * (b.lat - o.lat) - (a.lat - o.lat) * (b.lon - o.lon);
      let lower = [];
      for (let p of points) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) lower.pop();
        lower.push(p);
      }
      let upper = [];
      for (let i = points.length - 1; i >= 0; i--) {
        let p = points[i];
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) upper.pop();
        upper.push(p);
      }
      upper.pop();
      lower.pop();
      return lower.concat(upper);
    }

    /* Clear Animation Function */
    function clearAnimation() {
      pauseAnimation();
      Object.keys(deviceMarkers).forEach(dev => {
        if (deviceMarkers[dev]) {
          map.removeLayer(deviceMarkers[dev]);
          deviceMarkers[dev] = null;
        }
      });
      Object.keys(deviceLines).forEach(dev => {
        if (deviceLines[dev]) {
          map.removeLayer(deviceLines[dev]);
          deviceLines[dev] = null;
        }
      });
      allPositionMarkers.forEach(m => map.removeLayer(m));
      allPositionMarkers = [];
      allAccuracyRings.forEach(r => map.removeLayer(r));
      allAccuracyRings = [];
    }

    /* Handler for "Show All Positions" checkbox */
    function handleShowAllPositionsChange(checked) {
      if (checked) {
        allPositionsShown = true;
        showAllPositions();
      } else {
        allPositionsShown = false;
        allPositionMarkers.forEach(m => map.removeLayer(m));
        allPositionMarkers = [];
        allAccuracyRings.forEach(r => map.removeLayer(r));
        allAccuracyRings = [];
      }
    }
  </script>
  <script>
    /* If there's any "pastureData" in the URL, auto-load it */
    window.addEventListener('DOMContentLoaded', (event) => {
      const params = new URLSearchParams(window.location.search);
      const pastureData = params.get('pastureData');
      if (pastureData) {
        const decodedData = decodeURIComponent(pastureData);
        document.getElementById('pastureImportArea').value = decodedData;
        loadPastureData();
      }
    });
  </script>
  <!-- Login Script -->
  <script>
    const FIXED_USERNAME = 'ImNotAnAdmin';
    const FIXED_PASSWORD = '44FourOr22';
    const LOGIN_VERSION = 'v1';

    document.addEventListener('DOMContentLoaded', function() {
      const loginOverlay = document.getElementById('loginOverlay');
      if (localStorage.getItem('loggedIn') === 'true' &&
          localStorage.getItem('loginVersion') === LOGIN_VERSION) {
        loginOverlay.style.display = 'none';
      }
      document.getElementById('loginForm').addEventListener('submit', function(e) {
        e.preventDefault();
        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;
        if (username === FIXED_USERNAME && password === FIXED_PASSWORD) {
          localStorage.setItem('loggedIn', 'true');
          localStorage.setItem('loginVersion', LOGIN_VERSION);
          loginOverlay.style.display = 'none';
        } else {
          localStorage.removeItem('loggedIn');
          localStorage.removeItem('loginVersion');
          alert('Invalid credentials. Please try again.');
        }
      });
    });
  </script>
</body>
</html>
